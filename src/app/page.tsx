
"use client";

import { useState, useEffect } from "react";
import type { Task } from "@/lib/types";
import Header from "@/components/layout/header";
import TaskForm from "@/components/task-form";
import TaskListDisplay from "@/components/task-list-display";
import TaskInsightDialog from "@/components/task-insight-dialog";
import { provideTaskInsight, TaskInsightOutput } from "@/ai/flows/task-insight";
import type { CreateTaskListOutput } from "@/ai/flows/create-task-list";
import { useToast } from "@/hooks/use-toast";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Terminal } from "lucide-react";

const LOCAL_STORAGE_KEY = "pocketTasksAI_tasks";

export default function HomePage() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [aiMessage, setAiMessage] = useState<string | null>(null);
  const [isFormProcessing, setIsFormProcessing] = useState<boolean>(false);

  const [taskForInsight, setTaskForInsight] = useState<Task | null>(null);
  const [insightData, setInsightData] = useState<TaskInsightOutput | null>(null);
  const [isLoadingInsight, setIsLoadingInsight] = useState<boolean>(false);
  const [isInsightDialogOpen, setIsInsightDialogOpen] = useState<boolean>(false);

  const { toast } = useToast();

  useEffect(() => {
    const storedTasks = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (storedTasks) {
      try {
        const parsedTasks = JSON.parse(storedTasks);
        if (Array.isArray(parsedTasks)) {
           const tasksWithIds = parsedTasks.map(t => ({
            ...t,
            id: t.id || crypto.randomUUID() // Ensure tasks have IDs
          }));
          setTasks(tasksWithIds);
        }
      } catch (error) {
        console.error("Failed to parse tasks from localStorage", error);
        localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear corrupted data
      }
    }
  }, []);

  useEffect(() => {
    // Only run on client after mount to avoid SSR/localStorage mismatch
    if (typeof window !== "undefined") {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(tasks));
    }
  }, [tasks]);

  const handleListCreated = (data: CreateTaskListOutput) => {
    setIsFormProcessing(true); // Set immediately
    const newTasks: Task[] = data.taskList.map((text) => ({
      id: crypto.randomUUID(),
      text,
      completed: false,
    }));
    setTasks((prevTasks) => [...newTasks, ...prevTasks]);
    setAiMessage(data.reasoning || "Your new task list has been generated by AI!");
    toast({
      title: "Task list created!",
      description: data.reasoning || "AI has generated your tasks.",
    });
    // setIsFormProcessing(false) is handled by TaskForm's finally block
  };

  const handleToggleComplete = (id: string) => {
    let toggledTaskDescription = "";
    let newCompletedState = false;

    setTasks((prevTasks) =>
      prevTasks.map((task) => {
        if (task.id === id) {
          toggledTaskDescription = task.text;
          newCompletedState = !task.completed;
          return { ...task, completed: !task.completed };
        }
        return task;
      })
    );

    if (toggledTaskDescription) {
      toast({
        title: `Task ${newCompletedState ? "completed!" : "marked as incomplete"}`,
        description: `"${toggledTaskDescription}" state updated.`,
      });
    } else {
      console.warn(`Task with ID ${id} not found for toggling.`);
      toast({
        title: "Error",
        description: "Could not find the task to toggle.",
        variant: "destructive",
      });
    }
  };

  const handleDeleteTask = (id: string) => {
    let deletedTaskDescription = "";
    setTasks((prevTasks) => {
      const taskToDelete = prevTasks.find(task => task.id === id);
      if (taskToDelete) {
        deletedTaskDescription = taskToDelete.text;
      }
      return prevTasks.filter((task) => task.id !== id);
    });

    if (deletedTaskDescription) {
      toast({
        title: "Task deleted",
        description: `"${deletedTaskDescription}" has been removed.`,
      });
    } else {
      // This case should ideally not happen if ID is always valid and list hasn't changed unexpectedly
      console.warn(`Task with ID ${id} not found for deletion during state update.`);
      toast({
        title: "Error",
        description: "Could not find the task to delete.",
        variant: "destructive",
      });
    }
  };

  const handleUpdateTaskText = (id: string, newText: string) => {
     let originalTaskText = "";
    setTasks((prevTasks) =>
      prevTasks.map((task) => {
        if (task.id === id) {
          originalTaskText = task.text;
          return { ...task, text: newText };
        }
        return task;
      })
    );
    // The toast assumes the update was successful and text was different.
    // TaskItemDisplay should ensure not to call this if text is unchanged.
    toast({
      title: "Task updated!",
      description: `"${originalTaskText}" changed to "${newText}".`,
    });
  };

  const handleGetTaskInsight = async (task: Task) => { // Parameter is Task, not Task | null
    if (!task || !task.id) {
      console.error("Invalid task provided for insight:", task);
      toast({
        title: "Error",
        description: "Cannot get insights for an invalid or non-existent task.",
        variant: "destructive",
      });
      setIsInsightDialogOpen(false);
      return;
    }
    setTaskForInsight(task);
    setIsInsightDialogOpen(true);
    setIsLoadingInsight(true);
    setInsightData(null);
    try {
      const insight = await provideTaskInsight({
        task: task.text,
        taskList: tasks.map(t => t.text).join('\n'),
      });
      setInsightData(insight);
    } catch (error) {
      console.error("Failed to get task insight:", error);
      setInsightData(null);
      toast({
        title: "Error fetching insight",
        description: "Could not retrieve AI insights for this task. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsLoadingInsight(false);
    }
  };

  const handleAddSubTasksToList = (subTaskTexts: string[], parentTaskText: string) => {
    const newSubTasks: Task[] = subTaskTexts.map(text => ({
      id: crypto.randomUUID(),
      text: `Sub-task for "${parentTaskText}": ${text}`,
      completed: false,
    }));
    setTasks(prevTasks => [...newSubTasks, ...prevTasks]);
    const successMessage = `${newSubTasks.length} sub-tasks related to "${parentTaskText}" have been added to your main list.`;
    toast({
      title: "Sub-tasks added!",
      description: successMessage,
    });
    setAiMessage(successMessage);
  };

  const handleClearList = () => {
    if (tasks.length === 0) {
      toast({
        title: "List is already empty",
        description: "There are no tasks to remove.",
      });
      return;
    }
    setTasks([]);
    setAiMessage("All tasks have been cleared from your list.");
    toast({
      title: "List Cleared",
      description: "All tasks have been removed.",
    });
  };

  return (
    <div className="flex flex-col flex-grow">
      <Header onClearList={handleClearList} taskCount={tasks.length} />
      <main className="container mx-auto px-4 py-6 flex-grow flex flex-col gap-6">
        <TaskForm
          onListCreated={handleListCreated}
          isProcessing={isFormProcessing}
          setIsProcessing={setIsFormProcessing}
        />

        {aiMessage && !isFormProcessing && (
          <Alert className="bg-primary/10 border-primary/30 text-primary-foreground shadow-sm rounded-lg animate-in fade-in-50 slide-in-from-top-5 duration-500">
            <Terminal className="h-5 w-5 text-primary" />
            <AlertTitle className="font-headline text-primary">AI Assistant</AlertTitle>
            <AlertDescription>
              {aiMessage}
            </AlertDescription>
          </Alert>
        )}

        <div className="flex-grow">
          <TaskListDisplay
            tasks={tasks}
            onToggleComplete={handleToggleComplete}
            onDelete={handleDeleteTask}
            onUpdateText={handleUpdateTaskText}
            onGetInsight={handleGetTaskInsight}
          />
        </div>
      </main>

      <TaskInsightDialog
        isOpen={isInsightDialogOpen}
        onOpenChange={setIsInsightDialogOpen}
        taskText={taskForInsight?.text || null}
        insightData={insightData}
        isLoading={isLoadingInsight}
        onAddSubTasks={handleAddSubTasksToList}
      />
    </div>
  );
}
